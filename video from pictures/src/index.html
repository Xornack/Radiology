<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Security headers for XSS protection - VS Code Simple Browser compatible -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' blob: data:; media-src 'self' blob:; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'self' vscode-webview:;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="SAMEORIGIN">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <title>Video from Pictures - Test Interface</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .folder-selection {
            border: 2px dashed #ccc;
            padding: 40px;
            text-align: center;
            border-radius: 8px;
            margin: 20px 0;
            transition: border-color 0.3s;
        }
        .folder-selection:hover {
            border-color: #007bff;
        }
        .folder-selection.dragover {
            border-color: #28a745;
            background-color: #f8f9fa;
        }
        .btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
        }
        .btn:hover {
            background-color: #0056b3;
        }
        .btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .file-input {
            display: none;
        }
        .status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 4px;
            display: none;
        }
        .status.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .status.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .status.info {
            background-color: #cce7ff;
            border: 1px solid #b3d7ff;
            color: #004085;
        }
        .file-list {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            display: none;
        }
        .file-item {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            font-size: 14px;
        }
        .file-item:last-child {
            border-bottom: none;
        }
        .sorting-info {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
            display: none;
        }
        .sort-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px 2px;
        }
        .sort-btn:hover {
            background-color: #0056b3;
        }
        .sort-btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        
        /* Phase 2: Video Creation Styles */
        .video-summary {
            margin-top: 15px;
            padding: 15px;
            background-color: #e8f5e8;
            border-radius: 5px;
            border-left: 4px solid #28a745;
        }
        
        .video-summary h4 {
            margin-top: 0;
            color: #155724;
        }
        
        .video-progress {
            margin-top: 10px;
            padding: 10px;
            background-color: #fff3cd;
            border-radius: 4px;
            border-left: 4px solid #ffc107;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #007bff;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        /* Enhanced Progress Tracking Styles (Step 2.3) */
        .enhanced-progress-container {
            margin: 20px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            display: none;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .progress-title {
            font-weight: bold;
            color: #495057;
        }
        
        .eta-display {
            font-size: 14px;
            color: #6c757d;
            background-color: #e9ecef;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .step-progress {
            margin-bottom: 15px;
        }
        
        .step-indicator {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .step-number {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            margin-right: 10px;
        }
        
        .step-number.completed {
            background-color: #28a745;
            color: white;
        }
        
        .step-number.active {
            background-color: #007bff;
            color: white;
        }
        
        .step-number.pending {
            background-color: #e9ecef;
            color: #6c757d;
        }
        
        .step-name {
            flex-grow: 1;
            margin-right: 10px;
        }
        
        .step-status {
            font-size: 12px;
            color: #6c757d;
        }
        
        .current-item {
            font-size: 14px;
            color: #495057;
            margin-bottom: 10px;
            font-style: italic;
        }
        
        .statistics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .stat-item {
            text-align: center;
            padding: 10px;
            background-color: white;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        
        .stat-value {
            font-weight: bold;
            font-size: 18px;
            color: #007bff;
        }
        
        .stat-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 2px;
        }
        
        .confidence-indicator {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .confidence-high {
            background-color: #d4edda;
            color: #155724;
        }
        
        .confidence-medium {
            background-color: #fff3cd;
            color: #856404;
        }
        
        .confidence-low {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Video from Pictures</h1>
            <p>Convert JPEG medical image sequences to WebM videos</p>
        </div>

        <!-- Folder Selection Area -->
        <div class="folder-selection" id="folderSelection">
            <h3>Select Image Folder</h3>
            <p>Click to browse or drag and drop a folder containing JPEG images</p>
            <button class="btn" onclick="selectFolder()">Browse Folder</button>
            <input type="file" id="folderInput" class="file-input" webkitdirectory multiple accept="image/jpeg,image/jpg">
        </div>

        <!-- Status Messages -->
        <div id="statusMessage" class="status"></div>
        
        <!-- Session Status (Step 3.3) -->
        <div id="sessionStatus" class="session-status" style="display: none; background: #f8f9fa; padding: 10px; border-radius: 5px; margin: 10px 0; font-size: 14px; border-left: 4px solid #007bff;">
            <strong>Session:</strong> 0 operations | <strong>Success Rate:</strong> 0%
            <button class="btn" onclick="downloadSessionReport('html')" style="float: right; padding: 5px 10px; font-size: 12px;">üìÑ Download Report</button>
        </div>

        <!-- File List -->
        <div id="fileList" class="file-list"></div>

        <!-- Sorting Info -->
        <div id="sortingInfo" class="sorting-info"></div>

        <!-- Action Buttons -->
        <div style="text-align: center; margin-top: 20px;">
            <button class="btn" id="processBtn" disabled onclick="processImages()">Create Video</button>
            <button class="btn" id="settingsBtn" onclick="showSettings()">Settings</button>
        </div>
    </div>

    <!-- Load File System Access Module -->
    <script src="fileSystemAccess.js"></script>
    <script>
        // Global variables for testing
        let selectedFiles = [];
        let folderName = '';
        
        // Initialize Success/Failure Reporter (Step 3.3)
        let successFailureReporter = null;
        
        // Initialize reporter when page loads
        document.addEventListener('DOMContentLoaded', function() {
            successFailureReporter = new SuccessFailureReporter();
            
            // Set up callbacks for real-time UI updates
            successFailureReporter.onReportGenerated = function(report) {
                updateSuccessFailureUI(report);
            };
            
            // Show session status panel
            document.getElementById('sessionStatus').style.display = 'block';
            updateSuccessFailureUI({ type: 'session', status: 'initialized' });
            
            console.log('Success/Failure Reporter initialized');
        });

        // Folder selection functionality - Updated for Step 1.2 and Step 3.3
        async function selectFolder() {
            let operationId = null;
            
            try {
                // Start operation tracking (Step 3.3)
                if (successFailureReporter) {
                    operationId = successFailureReporter.reportOperationStart('file_selection', {
                        method: 'folder_browser'
                    });
                }
                
                showStatus('info', 'Selecting folder...');
                
                // Use the file system access module
                const result = await window.fileSystemModule.selectFiles();
                
                if (result.requiresUserAction) {
                    showStatus('info', result.message);
                    return;
                }
                
                if (result.success) {
                    // Report success (Step 3.3)
                    if (successFailureReporter && operationId) {
                        successFailureReporter.reportOperationSuccess(operationId, {
                            method: result.method,
                            folderName: result.folderName,
                            fileCount: result.files.length
                        });
                    }
                    
                    handleFolderSelectionResult(result);
                } else {
                    throw new Error(result.error);
                }
                
            } catch (error) {
                console.error('Folder selection error:', error);
                
                // Check if the error is a user cancellation
                const isCancellation = error.message && (
                    error.message.includes('cancelled') || 
                    error.message.includes('AbortError') ||
                    error.message.includes('User cancelled')
                );
                
                if (isCancellation) {
                    // User cancelled - don't show error or fallback
                    showStatus('info', 'Folder selection cancelled');
                    
                    // Report cancellation (Step 3.3)
                    if (successFailureReporter && operationId) {
                        successFailureReporter.reportOperationFailure(operationId, {
                            category: 'user_action',
                            severity: 'low',
                            message: 'User cancelled folder selection',
                            userCancelled: true
                        });
                    }
                    return; // Exit without fallback
                }
                
                // Report actual failure (Step 3.3)
                if (successFailureReporter && operationId) {
                    successFailureReporter.reportOperationFailure(operationId, {
                        category: 'file_access',
                        severity: 'medium',
                        message: error.message,
                        stack: error.stack
                    });
                }
                
                showStatus('error', `Failed to select folder: ${error.message}`);
                
                // Only fall back to file input for non-cancellation errors
                if (window.fileSystemModule.apiSupport.fileInput) {
                    showStatus('info', 'Falling back to file input method...');
                    document.getElementById('folderInput').click();
                }
            }
        }
        
        // Handle successful folder selection result - Updated for Step 1.4
        function handleFolderSelectionResult(result) {
            // Analyze and sort files using natural/numerical ordering
            const sortingAnalysis = window.fileSystemModule.analyzeSortingPattern(result.files);
            console.log('Sorting analysis:', sortingAnalysis);
            
            // Sort files using the recommended method
            selectedFiles = window.fileSystemModule.sortFiles(result.files, sortingAnalysis.recommended);
            folderName = result.folderName;
            
            showStatus('success', 
                `Found ${result.files.length} JPEG files in folder: ${result.folderName} (via ${result.method}). ` +
                `Sorted using ${sortingAnalysis.recommended} method (${Math.round(sortingAnalysis.confidence * 100)}% confidence).`
            );
            displayFileList(selectedFiles);
            displaySortingInfo(sortingAnalysis);
            document.getElementById('processBtn').disabled = false;
            
            // Log browser info for debugging
            console.log('Browser capabilities:', window.fileSystemModule.getBrowserInfo());
        }

        // Handle folder input change - Updated for Step 1.2 and 1.4
        document.getElementById('folderInput').addEventListener('change', function(event) {
            try {
                showStatus('info', 'Processing selected files...');
                
                const files = Array.from(event.target.files).filter(file => 
                    window.fileSystemModule.isValidJPEGFile(file)
                );
                
                if (files.length === 0) {
                    throw new Error('No JPEG files found in selected folder');
                }
                
                const folderName = files[0].webkitRelativePath 
                    ? files[0].webkitRelativePath.split('/')[0] 
                    : 'selected_folder';
                
                const result = {
                    method: 'fileInput',
                    files: files,
                    folderName: folderName,
                    success: true
                };
                
                handleFolderSelectionResult(result);
                
            } catch (error) {
                console.error('File input error:', error);
                showStatus('error', `Failed to process files: ${error.message}`);
            }
        });

        // Handle drag and drop
        const folderSelection = document.getElementById('folderSelection');
        
        folderSelection.addEventListener('dragover', function(e) {
            e.preventDefault();
            folderSelection.classList.add('dragover');
        });

        folderSelection.addEventListener('dragleave', function(e) {
            e.preventDefault();
            folderSelection.classList.remove('dragover');
        });

        folderSelection.addEventListener('drop', function(e) {
            e.preventDefault();
            folderSelection.classList.remove('dragover');
            
            try {
                showStatus('info', 'Processing dropped files...');
                
                // Use the file system access module for drag & drop
                const result = window.fileSystemModule.accessViaDragDrop(e.dataTransfer);
                
                if (result.success) {
                    handleFolderSelectionResult(result);
                } else {
                    throw new Error(result.error);
                }
                
            } catch (error) {
                console.error('Drag & drop error:', error);
                showStatus('error', `Failed to process dropped files: ${error.message}`);
            }
        });

        // Display file list
        function displayFileList(files) {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';
            
            files.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                // Use textContent to prevent XSS from malicious filenames
                fileItem.textContent = `${index + 1}. ${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
                fileList.appendChild(fileItem);
            });
            
            fileList.style.display = 'block';
        }

        // HTML escaping utility function for security
        function escapeHtml(text) {
            if (typeof text !== 'string') {
                text = String(text);
            }
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Input validation utility
        function validateInput(input, type = 'string', maxLength = 1000) {
            if (typeof input !== type) {
                throw new Error(`Invalid input type. Expected ${type}`);
            }
            if (type === 'string' && input.length > maxLength) {
                throw new Error(`Input too long. Maximum ${maxLength} characters allowed`);
            }
            return true;
        }
        
        // Sanitize filename for security
        function sanitizeFilename(filename) {
            if (!filename || typeof filename !== 'string') {
                return 'unknown_file';
            }
            // Remove path traversal attempts and dangerous characters
            return filename
                .replace(/[<>:"/\\|?*\x00-\x1f]/g, '_')
                .replace(/^\.+/, '_')
                .substring(0, 255) || 'sanitized_file';
        }

        // Display sorting information to user - Step 1.4
        function displaySortingInfo(sortingAnalysis) {
            const sortingInfo = document.getElementById('sortingInfo');
            if (sortingInfo) {
                // Escape user-controlled content to prevent XSS
                const escapedRecommended = escapeHtml(sortingAnalysis.recommended);
                const escapedReason = escapeHtml(sortingAnalysis.reason);
                
                sortingInfo.innerHTML = `
                    <div class="sorting-info">
                        <strong>Sorting:</strong> ${escapedRecommended} 
                        (${Math.round(sortingAnalysis.confidence * 100)}% confidence)
                        <br><small>${escapedReason}</small>
                        <br>
                        <button onclick="changeSortingMethod('natural')" class="sort-btn" 
                                ${sortingAnalysis.recommended === 'natural' ? 'disabled' : ''}>
                            Natural/Numerical
                        </button>
                        <button onclick="changeSortingMethod('dateModified')" class="sort-btn"
                                ${sortingAnalysis.recommended === 'dateModified' ? 'disabled' : ''}>
                            By Date Modified
                        </button>
                    </div>
                `;
                sortingInfo.style.display = 'block';
            }
        }

        // Change sorting method - Step 1.4
        function changeSortingMethod(newMethod) {
            if (selectedFiles.length === 0) {
                showStatus('error', 'No files selected to sort');
                return;
            }

            console.log(`Changing sorting method to: ${newMethod}`);
            selectedFiles = window.fileSystemModule.sortFiles(selectedFiles, newMethod);
            
            showStatus('success', `Files re-sorted using ${newMethod} method`);
            displayFileList(selectedFiles);
            
            // Update sorting info display
            const sortingAnalysis = {
                recommended: newMethod,
                confidence: 1.0,
                reason: `Manually selected ${newMethod} sorting`
            };
            displaySortingInfo(sortingAnalysis);
        }

        // Show status message with secure handling
        function showStatus(type, message) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.className = `status ${type}`;
            // Use textContent to prevent XSS in status messages
            statusEl.textContent = message;
            statusEl.style.display = 'block';
        }
        
        // Update UI with success/failure reporting information (Step 3.3)
        function updateSuccessFailureUI(report) {
            // Update session status indicator if it exists
            const sessionStatus = document.getElementById('sessionStatus');
            if (sessionStatus && successFailureReporter) {
                const status = successFailureReporter.getCurrentSessionStatus();
                // Clear existing content safely
                sessionStatus.innerHTML = '';
                
                // Create elements safely to prevent XSS
                const sessionText = document.createElement('span');
                sessionText.innerHTML = `<strong>Session:</strong> ${status.operationCount} operations | <strong>Success Rate:</strong> ${status.successRate}%`;
                
                const downloadBtn = document.createElement('button');
                downloadBtn.className = 'btn';
                downloadBtn.onclick = () => downloadSessionReport('html');
                downloadBtn.style.cssText = 'float: right; padding: 5px 10px; font-size: 12px;';
                downloadBtn.textContent = 'üìÑ Download Report';
                
                sessionStatus.appendChild(sessionText);
                sessionStatus.appendChild(downloadBtn);
            }
            
            // Handle different report types
            switch (report.type) {
                case 'operation':
                    if (report.status === 'started') {
                        console.log(`üîÑ Started: ${report.operation.type}`);
                    }
                    break;
                case 'success':
                    console.log(`‚úÖ Success: ${report.operation.type} completed`);
                    break;
                case 'error':
                    console.log(`‚ùå Error: ${report.operation.type} failed`);
                    break;
                case 'warning':
                    console.log(`‚ö†Ô∏è Warning: ${report.operation.type}`);
                    break;
            }
        }
        
        // Generate and download comprehensive session report (Step 3.3)
        function downloadSessionReport(format = 'html') {
            if (!successFailureReporter) {
                showStatus('error', 'Success/Failure Reporter not initialized');
                return;
            }
            
            try {
                const exportData = successFailureReporter.exportReport(format);
                if (exportData) {
                    // Create download link
                    const url = URL.createObjectURL(exportData.blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = exportData.filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showStatus('success', `Session report downloaded: ${exportData.filename}`);
                } else {
                    showStatus('error', 'Failed to generate session report');
                }
            } catch (error) {
                showStatus('error', `Report download failed: ${error.message}`);
            }
        }
        
        // Phase 2: Video Creation Implementation (Updated for Step 2.2 and Step 3.3)
        async function processImages() {
            let operationId = null;
            
            if (!selectedFiles || selectedFiles.length === 0) {
                showStatus('error', 'No images selected. Please select a folder first.');
                return;
            }

            try {
                // Start operation tracking (Step 3.3)
                if (successFailureReporter) {
                    operationId = successFailureReporter.reportOperationStart('video_conversion', {
                        inputFileCount: selectedFiles.length,
                        folderName: folderName
                    });
                }
                
                showStatus('info', 'Starting advanced video creation process...');
                const startTime = performance.now();
                
                // Create image-to-video converter instance
                const converter = new ImageToVideoConverter();
                
                // Set up progress tracking with enhanced UI (Step 2.3)
                converter.setCallbacks(
                    (progress) => {
                        // Handle both basic and enhanced progress updates
                        if (progress.enhanced) {
                            updateEnhancedProgress(progress);
                        } else {
                            showStatus('info', `${progress.message}${progress.percentage ? ` (${progress.percentage}%)` : ''}`);
                            if (progress.percentage !== null) {
                                updateProgressBar(progress.percentage);
                            }
                        }
                        
                        // Update enhanced progress for all progress types
                        updateEnhancedProgress(progress);
                    },
                    (error) => {
                        console.error('Conversion error:', error);
                        
                        // Report failure (Step 3.3)
                        if (successFailureReporter && operationId) {
                            successFailureReporter.reportOperationFailure(operationId, {
                                category: 'video_encoding',
                                severity: 'high',
                                message: error.error || error.message,
                                stage: 'conversion'
                            });
                        }
                        
                        showStatus('error', `Conversion failed: ${error.error}`);
                        hideProgressBar();
                    },
                    (result) => {
                        console.log('Conversion completed:', result);
                        
                        // Report success (Step 3.3)
                        if (successFailureReporter && operationId) {
                            const processingTime = performance.now() - startTime;
                            successFailureReporter.reportOperationSuccess(operationId, {
                                filename: result.filename,
                                outputFileSize: result.metadata.videoSize,
                                duration: result.metadata.duration,
                                processedFiles: result.metadata.processedImageCount
                            }, {
                                processingTime: processingTime,
                                compressionRatio: result.statistics.compressionRatio
                            });
                        }
                        
                        hideProgressBar();
                        displayAdvancedVideoSummary(result);
                    }
                );
                
                // Configure video settings (get from UI settings in Phase 4)
                const videoSettings = {
                    frameRate: 15,
                    quality: 'medium',
                    resolution: 'original',
                    codec: 'vp8',
                    format: 'webm'
                };
                
                converter.updateSettings(videoSettings);
                
                showStatus('info', `Processing ${selectedFiles.length} images for video creation...`);
                
                // Set up enhanced progress tracking (Step 2.3)
                setupEnhancedProgressTracking();
                
                // Convert images to video
                const result = await converter.convertImagesToVideo(selectedFiles);
                
                if (result.success) {
                    showStatus('success', `Video created successfully! ${result.filename}`);
                    
                    // Store video data for additional operations (Step 3.1)
                    currentVideoBlob = result.videoBlob;
                    currentVideoFilename = result.filename;
                    
                    // Download the video with enhanced save functionality
                    await downloadVideo(result.videoBlob, result.filename);
                    
                    // Display comprehensive results
                    displayAdvancedVideoSummary(result);
                    
                } else {
                    throw new Error('Video creation failed');
                }
                
            } catch (error) {
                console.error('Video processing error:', error);
                showStatus('error', `Video creation failed: ${error.message}`);
                hideProgressBar();
            }
        }
        
        // Update progress bar display
        function updateProgressBar(percentage) {
            let progressContainer = document.getElementById('progressContainer');
            let progressFill = document.getElementById('progressFill');
            
            if (!progressContainer) {
                // Create progress bar if it doesn't exist
                progressContainer = document.createElement('div');
                progressContainer.id = 'progressContainer';
                progressContainer.className = 'progress-container';
                progressContainer.innerHTML = `
                    <h4>Video Creation Progress:</h4>
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill" style="width: 0%;">0%</div>
                    </div>
                `;
                const statusElement = document.getElementById('statusMessage');
                if (statusElement && statusElement.parentNode) {
                    statusElement.parentNode.insertBefore(progressContainer, statusElement.nextSibling);
                } else {
                    // Fallback: append to document body if statusMessage element not found
                    document.body.appendChild(progressContainer);
                }
                progressFill = document.getElementById('progressFill');
            }
            
            progressContainer.style.display = 'block';
            progressFill.style.width = `${percentage}%`;
            progressFill.textContent = `${percentage}%`;
        }
        
        // Hide progress bar
        function hideProgressBar() {
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
            
            const enhancedProgressContainer = document.getElementById('enhancedProgressContainer');
            if (enhancedProgressContainer) {
                enhancedProgressContainer.style.display = 'none';
            }
        }
        
        // Enhanced Progress Tracking Functions (Step 2.3)
        function setupEnhancedProgressTracking() {
            // Create enhanced progress container if it doesn't exist
            let enhancedContainer = document.getElementById('enhancedProgressContainer');
            if (!enhancedContainer) {
                enhancedContainer = document.createElement('div');
                enhancedContainer.id = 'enhancedProgressContainer';
                enhancedContainer.className = 'enhanced-progress-container';
                enhancedContainer.innerHTML = createEnhancedProgressHTML();
                
                const statusElement = document.getElementById('statusMessage');
                if (statusElement && statusElement.parentNode) {
                    statusElement.parentNode.insertBefore(enhancedContainer, statusElement.nextSibling);
                } else {
                    // Fallback: append to document body if statusMessage element not found
                    document.body.appendChild(enhancedContainer);
                }
            }
            
            enhancedContainer.style.display = 'block';
        }
        
        function createEnhancedProgressHTML() {
            return `
                <div class="progress-header">
                    <div class="progress-title">Video Creation Progress</div>
                    <div id="etaDisplay" class="eta-display">Calculating ETA...</div>
                </div>
                
                <div class="step-progress">
                    <div id="stepIndicators"></div>
                    <div id="currentItem" class="current-item"></div>
                    
                    <div class="progress-bar">
                        <div id="enhancedProgressFill" class="progress-fill" style="width: 0%;"></div>
                    </div>
                </div>
                
                <div id="statisticsGrid" class="statistics-grid">
                    <div class="stat-item">
                        <div id="elapsedTime" class="stat-value">0s</div>
                        <div class="stat-label">Elapsed</div>
                    </div>
                    <div class="stat-item">
                        <div id="itemsPerSecond" class="stat-value">0</div>
                        <div class="stat-label">Items/sec</div>
                    </div>
                    <div class="stat-item">
                        <div id="completedSteps" class="stat-value">0/0</div>
                        <div class="stat-label">Steps</div>
                    </div>
                    <div class="stat-item">
                        <div id="confidence" class="stat-value">
                            <span class="confidence-indicator confidence-low">Low</span>
                        </div>
                        <div class="stat-label">ETA Confidence</div>
                    </div>
                </div>
            `;
        }
        
        function updateEnhancedProgress(progressData) {
            if (progressData.step === 'step-progress') {
                updateStepIndicators(progressData.stepInfo);
            } else if (progressData.step === 'eta-update') {
                updateETADisplay(progressData.eta);
            } else if (progressData.step === 'statistics-update') {
                updateStatisticsDisplay(progressData.statistics);
            } else if (progressData.overall !== undefined) {
                updateOverallProgress(progressData);
            }
        }
        
        function updateStepIndicators(stepInfo) {
            const stepIndicators = document.getElementById('stepIndicators');
            if (!stepIndicators) return;
            
            const steps = [
                { id: 'validation', name: 'Image Validation' },
                { id: 'processing', name: 'Image Processing' },
                { id: 'encoder-init', name: 'Encoder Setup' },
                { id: 'encoding', name: 'Video Encoding' },
                { id: 'finalization', name: 'Finalization' }
            ];
            
            let html = '';
            steps.forEach((step, index) => {
                let status = 'pending';
                if (index < stepInfo.completedSteps) {
                    status = 'completed';
                } else if (stepInfo.currentStep === step.id) {
                    status = 'active';
                }
                
                html += `
                    <div class="step-indicator">
                        <div class="step-number ${status}">${index + 1}</div>
                        <div class="step-name">${step.name}</div>
                        <div class="step-status">${status}</div>
                    </div>
                `;
            });
            
            stepIndicators.innerHTML = html;
            
            // Update completed steps counter
            const completedStepsElement = document.getElementById('completedSteps');
            if (completedStepsElement) {
                completedStepsElement.textContent = `${stepInfo.completedSteps}/${stepInfo.totalSteps}`;
            }
        }
        
        function updateETADisplay(eta) {
            const etaDisplay = document.getElementById('etaDisplay');
            if (etaDisplay) {
                etaDisplay.textContent = `ETA: ${eta.formatted}`;
            }
            
            const confidenceElement = document.getElementById('confidence');
            if (confidenceElement) {
                confidenceElement.innerHTML = `
                    <span class="confidence-indicator confidence-${eta.confidence}">${eta.confidence}</span>
                `;
            }
        }
        
        function updateStatisticsDisplay(statistics) {
            // Update elapsed time
            const elapsedTimeElement = document.getElementById('elapsedTime');
            if (elapsedTimeElement) {
                elapsedTimeElement.textContent = statistics.timing.totalElapsedFormatted;
            }
            
            // Update items per second
            const itemsPerSecondElement = document.getElementById('itemsPerSecond');
            if (itemsPerSecondElement) {
                const rate = statistics.performance.overallItemsPerSecond.toFixed(1);
                itemsPerSecondElement.textContent = rate;
            }
        }
        
        function updateOverallProgress(progressData) {
            const progressFill = document.getElementById('enhancedProgressFill');
            if (progressFill) {
                const percentage = Math.round(progressData.overall || 0);
                progressFill.style.width = `${percentage}%`;
                progressFill.textContent = `${percentage}%`;
            }
            
            const currentItemElement = document.getElementById('currentItem');
            if (currentItemElement && progressData.currentItem) {
                currentItemElement.textContent = `Processing: ${progressData.currentItem}`;
            }
        }
        
        // Enhanced video saving functionality (Step 3.1)
        let fileSaver = null;
        
        // Initialize file saver
        function initializeFileSaver() {
            if (!fileSaver) {
                fileSaver = new FileSaver();
                console.log('FileSaver initialized:', fileSaver.getBrowserCapabilities());
            }
            return fileSaver;
        }
        
        // Enhanced video download/save function (Step 3.1)
        async function downloadVideo(blob, filename) {
            const saver = initializeFileSaver();
            
            try {
                // Show save status
                showStatus('info', 'Saving video file...');
                
                // Save the video with enhanced options
                const result = await saver.saveVideo(blob, filename, {
                    generateUniqueNames: true,
                    confirmOverwrite: true
                });
                
                if (result.success) {
                    showStatus('success', 
                        `Video saved successfully! ` +
                        `File: ${result.filename} (${(result.size / 1024 / 1024).toFixed(2)} MB) ` +
                        `via ${result.method}${result.location ? ` to ${result.location}` : ''}`
                    );
                    
                    // Display save result details
                    displaySaveResult(result);
                    
                    return result;
                } else {
                    if (result.cancelled) {
                        showStatus('info', 'Save operation was cancelled by user');
                    } else {
                        throw new Error(result.error || 'Save operation failed');
                    }
                }
            } catch (error) {
                console.error('Failed to save video:', error);
                showStatus('error', `Failed to save video: ${error.message}`);
                
                // Fall back to basic download if enhanced save fails
                try {
                    console.log('Falling back to basic download method...');
                    return await basicVideoDownload(blob, filename);
                } catch (fallbackError) {
                    console.error('Fallback download also failed:', fallbackError);
                    showStatus('error', `All save methods failed: ${fallbackError.message}`);
                    return { success: false, error: fallbackError.message };
                }
            }
        }
        
        // Basic video download (fallback method)
        async function basicVideoDownload(blob, filename) {
            try {
                console.log('basicVideoDownload called with:');
                console.log('blob:', blob);
                console.log('blob type:', typeof blob);
                console.log('blob instanceof Blob:', blob instanceof Blob);
                console.log('blob size:', blob ? blob.size : 'N/A');
                console.log('blob type property:', blob ? blob.type : 'N/A');
                console.log('filename:', filename);
                
                // Validate that blob is actually a Blob
                if (!blob) {
                    throw new Error('No blob provided');
                }
                
                if (!(blob instanceof Blob)) {
                    throw new Error(`Invalid blob type. Expected Blob, got ${typeof blob}`);
                }
                
                if (blob.size === 0) {
                    throw new Error('Blob is empty (size = 0)');
                }
                
                console.log('Creating object URL for blob...');
                const url = URL.createObjectURL(blob);
                console.log('Object URL created:', url);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                
                document.body.appendChild(a);
                console.log('Triggering download...');
                a.click();
                document.body.removeChild(a);
                
                // Clean up URL object
                setTimeout(() => {
                    console.log('Revoking object URL...');
                    URL.revokeObjectURL(url);
                }, 1000);
                
                showStatus('success', `Video downloaded using fallback method: ${filename}`);
                
                return {
                    success: true,
                    method: 'fallback-download',
                    filename: filename,
                    location: 'Browser downloads folder',
                    size: blob.size
                };
            } catch (error) {
                throw new Error(`Fallback download failed: ${error.message}`);
            }
        }
        
        // Display detailed save result (Step 3.1)
        function displaySaveResult(saveResult) {
            const existingSaveResult = document.querySelector('.save-result-details');
            if (existingSaveResult) {
                existingSaveResult.remove();
            }
            
            const saveResultElement = document.createElement('div');
            saveResultElement.className = 'save-result-details';
            
            // Escape user-controlled content to prevent XSS
            const escapedFilename = escapeHtml(saveResult.filename);
            const escapedMethod = escapeHtml(saveResult.method);
            const escapedLocation = escapeHtml(saveResult.location || 'Default location');
            const escapedNote = saveResult.note ? escapeHtml(saveResult.note) : '';
            
            saveResultElement.innerHTML = `
                <div style="margin-top: 15px; padding: 15px; background-color: #e8f5e8; border-radius: 8px; border-left: 4px solid #28a745;">
                    <h4>üíæ File Save Details</h4>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                        <div>
                            <strong>üìÅ File Information:</strong><br>
                            <small>Name: ${escapedFilename}</small><br>
                            <small>Size: ${(saveResult.size / 1024 / 1024).toFixed(2)} MB</small><br>
                            <small>Saved: ${new Date(saveResult.timestamp).toLocaleString()}</small>
                        </div>
                        
                        <div>
                            <strong>üîß Save Method:</strong><br>
                            <small>Method: ${escapedMethod}</small><br>
                            <small>Location: ${escapedLocation}</small><br>
                            ${saveResult.note ? `<small>Note: ${escapedNote}</small>` : ''}
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; text-align: center;">
                        <button class="btn" onclick="showSaveOptions()">‚öôÔ∏è Save Options</button>
                        <button class="btn" onclick="saveWithDifferentMethod('${escapedFilename}')">üíæ Save Copy</button>
                    </div>
                </div>
            `;
            
            const statusElement = document.getElementById('statusMessage');
            if (statusElement && statusElement.parentNode) {
                statusElement.parentNode.insertBefore(saveResultElement, statusElement.nextSibling);
            } else {
                // Fallback: append to document body if statusMessage element not found
                document.body.appendChild(saveResultElement);
            }
        }
        
        // Show save options dialog (Step 3.1)
        function showSaveOptions() {
            const saver = initializeFileSaver();
            const capabilities = saver.validateSaveCapabilities();
            const currentSettings = saver.settings;
            
            const optionsDialog = document.createElement('div');
            optionsDialog.id = 'saveOptionsDialog';
            optionsDialog.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;
            
            const dialogContent = document.createElement('div');
            dialogContent.style.cssText = `
                background-color: white;
                padding: 30px;
                border-radius: 8px;
                max-width: 600px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            `;
            
            dialogContent.innerHTML = `
                <h3>Save Options & Capabilities</h3>
                
                <div style="margin: 20px 0;">
                    <h4>Available Save Methods:</h4>
                    ${capabilities.available.map(method => `
                        <div style="margin: 10px 0; padding: 10px; border: 1px solid ${method.recommended ? '#28a745' : '#6c757d'}; border-radius: 4px;">
                            <strong>${method.method}</strong> ${method.recommended ? '‚úÖ' : 'üìÅ'}
                            <br><small>${method.description}</small>
                        </div>
                    `).join('')}
                </div>
                
                <div style="margin: 20px 0;">
                    <h4>Current Settings:</h4>
                    <label style="display: block; margin: 10px 0;">
                        <input type="checkbox" id="generateUniqueNames" ${currentSettings.generateUniqueNames ? 'checked' : ''}> 
                        Generate unique filenames with timestamps
                    </label>
                    <label style="display: block; margin: 10px 0;">
                        <input type="checkbox" id="confirmOverwrite" ${currentSettings.confirmOverwrite ? 'checked' : ''}> 
                        Confirm before overwriting existing files
                    </label>
                    <label style="display: block; margin: 10px 0;">
                        <input type="checkbox" id="autoSave" ${currentSettings.autoSave ? 'checked' : ''}> 
                        Auto-save without prompting (when possible)
                    </label>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="applySaveOptions()" style="padding: 8px 16px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin: 5px;">Apply Settings</button>
                    <button onclick="closeSaveOptions()" style="padding: 8px 16px; background-color: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; margin: 5px;">Close</button>
                </div>
            `;
            
            optionsDialog.appendChild(dialogContent);
            document.body.appendChild(optionsDialog);
            
            // Add scoped functions for dialog interaction to prevent global pollution
            const applySaveOptions = () => {
                const newSettings = {
                    generateUniqueNames: document.getElementById('generateUniqueNames').checked,
                    confirmOverwrite: document.getElementById('confirmOverwrite').checked,
                    autoSave: document.getElementById('autoSave').checked
                };
                
                saver.updateSettings(newSettings);
                showStatus('success', 'Save options updated successfully');
                document.body.removeChild(optionsDialog);
            };
            
            const closeSaveOptions = () => {
                document.body.removeChild(optionsDialog);
            };
            
            // Add event listeners instead of global onclick handlers
            const applyBtn = optionsDialog.querySelector('button[onclick*="applySaveOptions"]');
            const closeBtn = optionsDialog.querySelector('button[onclick*="closeSaveOptions"]');
            
            if (applyBtn) {
                applyBtn.removeAttribute('onclick');
                applyBtn.addEventListener('click', applySaveOptions);
            }
            if (closeBtn) {
                closeBtn.removeAttribute('onclick');
                closeBtn.addEventListener('click', closeSaveOptions);
            }
        }
        
        // Save with different method (Step 3.1)
        async function saveWithDifferentMethod(filename) {
            if (!currentVideoBlob) {
                showStatus('error', 'No video data available. Please create a video first.');
                return;
            }
            
            const saver = initializeFileSaver();
            
            try {
                showStatus('info', 'Saving additional copy with different method...');
                
                // Let user choose save method
                const result = await saver.saveWithMethodChoice(currentVideoBlob, filename || currentVideoFilename);
                
                if (result && result.success) {
                    showStatus('success', `Additional copy saved: ${result.filename} via ${result.method}`);
                    displaySaveResult(result);
                } else if (result && result.cancelled) {
                    showStatus('info', 'Save operation was cancelled by user');
                } else {
                    showStatus('error', 'Failed to save additional copy');
                }
            } catch (error) {
                console.error('Failed to save with different method:', error);
                showStatus('error', `Failed to save copy: ${error.message}`);
            }
        }
        
        // Display advanced video creation summary (Step 2.2 enhancement)
        function displayAdvancedVideoSummary(result) {
            const summaryDiv = document.getElementById('statusMessage');
            const existingSummary = document.querySelector('.video-summary-advanced');
            
            // Remove existing summary if present
            if (existingSummary) {
                existingSummary.remove();
            }
            
            const summaryElement = document.createElement('div');
            summaryElement.className = 'video-summary-advanced';
            
            // Escape user-controlled content to prevent XSS
            const escapedFilename = escapeHtml(result.filename);
            const escapedCodec = escapeHtml(result.metadata.settings.codec);
            const escapedQuality = escapeHtml(result.metadata.settings.quality);
            
            summaryElement.innerHTML = `
                <div style="margin-top: 20px; padding: 20px; background-color: #e8f5e8; border-radius: 8px; border-left: 4px solid #28a745;">
                    <h4>‚úÖ Video Creation Completed Successfully</h4>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                        <div>
                            <h5>üìÅ File Information</h5>
                            <p><strong>Filename:</strong> ${escapedFilename}</p>
                            <p><strong>Size:</strong> ${result.metadata.videoSize ? (result.metadata.videoSize / 1024 / 1024).toFixed(2) + ' MB' : 'N/A'}</p>
                            <p><strong>Created:</strong> ${new Date(result.metadata.createdAt).toLocaleString()}</p>
                        </div>
                        
                        <div>
                            <h5>üé¨ Video Properties</h5>
                            <p><strong>Duration:</strong> ${result.metadata.duration.formatted}</p>
                            <p><strong>Dimensions:</strong> ${result.metadata.dimensions.width}x${result.metadata.dimensions.height}</p>
                            <p><strong>Aspect Ratio:</strong> ${result.metadata.dimensions.aspectRatio}</p>
                        </div>
                        
                        <div>
                            <h5>‚öôÔ∏è Encoding Settings</h5>
                            <p><strong>Frame Rate:</strong> ${result.metadata.settings.frameRate} FPS</p>
                            <p><strong>Quality:</strong> ${escapedQuality}</p>
                            <p><strong>Codec:</strong> ${escapedCodec}</p>
                        </div>
                        
                        <div>
                            <h5>üìä Processing Statistics</h5>
                            <p><strong>Input Images:</strong> ${result.metadata.inputImageCount}</p>
                            <p><strong>Processed:</strong> ${result.metadata.processedImageCount}</p>
                            <p><strong>Compression:</strong> ${result.statistics.compressionRatio.percentage}% reduction</p>
                            <p><strong>Processing Time:</strong> ${(result.statistics.totalProcessingTime / 1000).toFixed(1)}s</p>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; text-align: center;">
                        <button class="btn" onclick="showVideoMetadata(${JSON.stringify(result.metadata).replace(/"/g, '&quot;')})">üìã View Full Metadata</button>
                    </div>
                </div>
            `;
            
            if (summaryDiv && summaryDiv.parentNode) {
                summaryDiv.parentNode.insertBefore(summaryElement, summaryDiv.nextSibling);
            } else {
                // Fallback: append to document body if statusMessage element not found
                document.body.appendChild(summaryElement);
            }
            hideProgressBar();
        }
        
        // Test video file functionality (Step 3.2 implementation)
        // Show video test progress
        function showVideoTestProgress(message, percentage) {
            let progressContainer = document.getElementById('videoTestProgress');
            
            if (!progressContainer) {
                progressContainer = document.createElement('div');
                progressContainer.id = 'videoTestProgress';
                progressContainer.className = 'video-progress';
                progressContainer.innerHTML = `
                    <h4>üî¨ Video Testing Progress</h4>
                    <div id="videoTestMessage" class="progress-message"></div>
                    <div class="progress-bar">
                        <div id="videoTestProgressFill" class="progress-fill" style="width: 0%;"></div>
                    </div>
                `;
                
                const statusElement = document.getElementById('statusMessage');
                if (statusElement && statusElement.parentNode) {
                    statusElement.parentNode.insertBefore(progressContainer, statusElement.nextSibling);
                } else {
                    // Fallback: append to document body if statusMessage element not found
                    document.body.appendChild(progressContainer);
                }
            }
            
            progressContainer.style.display = 'block';
            document.getElementById('videoTestMessage').textContent = message;
            
            if (percentage !== undefined) {
                const progressFill = document.getElementById('videoTestProgressFill');
                progressFill.style.width = `${percentage}%`;
                progressFill.textContent = `${percentage}%`;
            }
        }
        
        // Hide video test progress
        function hideVideoTestProgress() {
            const progressContainer = document.getElementById('videoTestProgress');
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
        }
        
        // Display video test results
        function displayVideoTestResults(testResults, report) {
            const existingResults = document.querySelector('.video-test-results');
            if (existingResults) {
                existingResults.remove();
            }
            
            const resultsElement = document.createElement('div');
            resultsElement.className = 'video-test-results';
            
            const summary = report.summary;
            const statusColor = summary.overall === 'PASSED' ? '#28a745' : '#dc3545';
            const statusIcon = summary.overall === 'PASSED' ? '‚úÖ' : '‚ùå';
            
            resultsElement.innerHTML = `
                <div style="margin-top: 20px; padding: 20px; background-color: #f8f9fa; border-radius: 8px; border-left: 4px solid ${statusColor};">
                    <h4>${statusIcon} Video Validation Results</h4>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                        <div>
                            <h5>üìã Test Summary</h5>
                            <p><strong>Overall Status:</strong> <span style="color: ${statusColor};">${summary.overall}</span></p>
                            <p><strong>Tests Passed:</strong> ${summary.testsPassed}/${summary.testsRun}</p>
                            <p><strong>Duration:</strong> ${summary.testDuration}</p>
                            <p><strong>Warnings:</strong> ${summary.warnings}</p>
                        </div>
                        
                        <div>
                            <h5>üé¨ Video Quality</h5>
                            <p><strong>Duration:</strong> ${summary.videoInfo?.duration || 'Unknown'}</p>
                            <p><strong>Dimensions:</strong> ${summary.videoInfo?.dimensions || 'Unknown'}</p>
                            <p><strong>File Size:</strong> ${summary.videoInfo?.fileSize || 'Unknown'}</p>
                            <p><strong>Aspect Ratio:</strong> ${summary.videoInfo?.aspectRatio || 'Unknown'}</p>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <h5>üî¨ Test Details</h5>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                            ${Object.entries(testResults.tests).map(([testName, result]) => {
                                const icon = result.status === 'passed' ? '‚úÖ' : result.status === 'failed' ? '‚ùå' : '‚ö†Ô∏è';
                                // Escape test name to prevent XSS
                                const escapedTestName = escapeHtml(formatTestName(testName));
                                const escapedStatus = escapeHtml(result.status.toUpperCase());
                                return `
                                    <div style="padding: 10px; border: 1px solid #dee2e6; border-radius: 4px; background-color: white;">
                                        <strong>${icon} ${escapedTestName}</strong>
                                        <br><small style="color: #6c757d;">${escapedStatus}</small>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    
                    ${testResults.warnings && testResults.warnings.length > 0 ? `
                    <div style="margin-top: 15px;">
                        <h5>‚ö†Ô∏è Warnings</h5>
                        <ul style="margin: 0; padding-left: 20px;">
                            ${testResults.warnings.map(warning => `<li style="color: #856404;">${escapeHtml(warning)}</li>`).join('')}
                        </ul>
                    </div>
                    ` : ''}
                    
                    ${testResults.recommendations && testResults.recommendations.length > 0 ? `
                    <div style="margin-top: 15px;">
                        <h5>üí° Recommendations</h5>
                        <ul style="margin: 0; padding-left: 20px;">
                            ${testResults.recommendations.map(rec => `<li style="color: #004085;">${escapeHtml(rec)}</li>`).join('')}
                        </ul>
                    </div>
                    ` : ''}
                    
                    <div style="margin-top: 20px; text-align: center;">
                        <button class="btn" onclick="runQuickVideoTest()">üîÑ Quick Re-test</button>
                        <button class="btn" onclick="showDetailedTestReport(${JSON.stringify(report).replace(/"/g, '&quot;')})">üìÑ Detailed Report</button>
                        <button class="btn" onclick="downloadTestReport(${JSON.stringify(report).replace(/"/g, '&quot;')})">üíæ Save Report</button>
                    </div>
                </div>
            `;
            
            const statusElement = document.getElementById('statusMessage');
            if (statusElement && statusElement.parentNode) {
                statusElement.parentNode.insertBefore(resultsElement, statusElement.nextSibling);
            } else {
                // Fallback: append to document body if statusMessage element not found
                document.body.appendChild(resultsElement);
            }
        }
        
        // Format test name for display
        function formatTestName(testName) {
            return testName
                .replace(/([A-Z])/g, ' $1')
                .replace(/^./, str => str.toUpperCase())
                .trim();
        }
        
        // Run quick video test
        async function runQuickVideoTest() {
            if (!currentVideoBlob) {
                showStatus('error', 'No video data available.');
                return;
            }
            
            try {
                showStatus('info', 'Running quick video validation...');
                const tester = new VideoTester();
                const reporter = new VideoReporter();
                
                showVideoTestProgress('Quick validation in progress...', 50);
                
                const results = await tester.quickTest(currentVideoBlob, currentVideoFilename);
                const report = reporter.generateTestReport(results, currentVideoBlob);
                
                hideVideoTestProgress();
                
                if (results.success) {
                    showStatus('success', 'Quick validation passed!');
                } else {
                    showStatus('warning', 'Quick validation found issues.');
                }
                
                displayVideoTestResults(results, report);
                
            } catch (error) {
                hideVideoTestProgress();
                showStatus('error', `Quick test failed: ${error.message}`);
            }
        }
        
        // Show detailed test report
        function showDetailedTestReport(report) {
            const reportWindow = window.open('', '_blank', 'width=800,height=600,scrollbars=yes');
            const reporter = new VideoReporter();
            const htmlReport = reporter.exportAsHTML(report);
            
            reportWindow.document.write(htmlReport);
            reportWindow.document.close();
        }
        
        // Download test report
        async function downloadTestReport(report) {
            try {
                const reporter = new VideoReporter();
                const result = await reporter.saveReport(report, currentVideoFilename || 'video', 'html');
                
                if (result.success) {
                    showStatus('success', `Test report saved: ${result.filename}`);
                } else {
                    showStatus('error', `Failed to save report: ${result.error}`);
                }
            } catch (error) {
                showStatus('error', `Failed to save report: ${error.message}`);
            }
        }
        
        // Play test video in popup
        // Store current video blob for additional operations (Step 3.1 enhancement)
        let currentVideoBlob = null;
        let currentVideoFilename = null;
        
        // Enhanced video creation completion handler
        function handleVideoCreationSuccess(result) {
            // Store video data for additional operations
            currentVideoBlob = result.videoBlob;
            currentVideoFilename = result.filename;
            
            console.log('Video creation completed:', result);
            hideProgressBar();
            displayAdvancedVideoSummary(result);
        }
        
        // Show detailed metadata
        function showVideoMetadata(metadata) {
            const metadataWindow = window.open('', '_blank', 'width=600,height=400');
            
            // Escape the metadata display to prevent XSS
            const escapedMetadata = escapeHtml(JSON.stringify(metadata, null, 2));
            const escapedCreatedAt = escapeHtml(metadata.createdAt || 'Unknown');
            
            metadataWindow.document.write(`
                <html>
                <head><title>Video Metadata - ${escapedCreatedAt}</title></head>
                <body style="font-family: Arial, sans-serif; padding: 20px;">
                    <h2>Video Creation Metadata</h2>
                    <pre style="background-color: #f8f9fa; padding: 15px; border-radius: 4px; overflow: auto;">${escapedMetadata}</pre>
                    <div style="margin-top: 20px; text-align: center;">
                        <button onclick="window.close()" style="padding: 8px 16px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
                    </div>
                </body>
                </html>
            `);
            metadataWindow.document.close();
        }

        function showSettings() {
            // Create settings dialog
            const settingsDialog = document.createElement('div');
            settingsDialog.id = 'settingsDialog';
            settingsDialog.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;
            
            // Get current settings from the converter
            const currentSettings = {
                frameRate: 15,
                quality: 'medium',
                resolution: 'original',
                format: 'webm'
            };
            
            settingsDialog.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 8px; width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto;">
                    <h3 style="margin-top: 0; color: #333;">Video Settings</h3>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Frame Rate (FPS):</label>
                        <select id="frameRateSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <option value="5" ${currentSettings.frameRate === 5 ? 'selected' : ''}>5 FPS (Very Slow)</option>
                            <option value="10" ${currentSettings.frameRate === 10 ? 'selected' : ''}>10 FPS (Slow)</option>
                            <option value="15" ${currentSettings.frameRate === 15 ? 'selected' : ''}>15 FPS (Default)</option>
                            <option value="24" ${currentSettings.frameRate === 24 ? 'selected' : ''}>24 FPS (Cinema)</option>
                            <option value="30" ${currentSettings.frameRate === 30 ? 'selected' : ''}>30 FPS (Smooth)</option>
                            <option value="60" ${currentSettings.frameRate === 60 ? 'selected' : ''}>60 FPS (Very Smooth)</option>
                        </select>
                        <small style="color: #666;">Higher frame rates create smoother video but larger file sizes</small>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Video Quality:</label>
                        <select id="qualitySelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <option value="low" ${currentSettings.quality === 'low' ? 'selected' : ''}>Low (Smaller files)</option>
                            <option value="medium" ${currentSettings.quality === 'medium' ? 'selected' : ''}>Medium (Balanced)</option>
                            <option value="high" ${currentSettings.quality === 'high' ? 'selected' : ''}>High (Better quality)</option>
                        </select>
                        <small style="color: #666;">Higher quality preserves more detail but creates larger files</small>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Resolution:</label>
                        <select id="resolutionSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <option value="original" ${currentSettings.resolution === 'original' ? 'selected' : ''}>Original (Preserve medical image resolution)</option>
                            <option value="1080p" ${currentSettings.resolution === '1080p' ? 'selected' : ''}>1080p (1920x1080)</option>
                            <option value="720p" ${currentSettings.resolution === '720p' ? 'selected' : ''}>720p (1280x720)</option>
                            <option value="480p" ${currentSettings.resolution === '480p' ? 'selected' : ''}>480p (854x480)</option>
                        </select>
                        <small style="color: #666;">Original resolution is recommended for medical images</small>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Output Format:</label>
                        <select id="formatSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <option value="webm" ${currentSettings.format === 'webm' ? 'selected' : ''}>WebM (Browser optimized)</option>
                        </select>
                        <small style="color: #666;">WebM format ensures compatibility with all modern browsers</small>
                    </div>
                    
                    <div style="margin-top: 30px; text-align: right;">
                        <button onclick="closeSettings()" style="padding: 10px 20px; background-color: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">Cancel</button>
                        <button onclick="applySettings()" style="padding: 10px 20px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Apply Settings</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(settingsDialog);
        }
        
        function closeSettings() {
            const dialog = document.getElementById('settingsDialog');
            if (dialog) {
                dialog.remove();
            }
        }
        
        function applySettings() {
            const frameRate = parseInt(document.getElementById('frameRateSelect').value);
            const quality = document.getElementById('qualitySelect').value;
            const resolution = document.getElementById('resolutionSelect').value;
            const format = document.getElementById('formatSelect').value;
            
            // Update converter settings if converter exists
            if (window.imageToVideoConverter) {
                const newSettings = {
                    frameRate: frameRate,
                    quality: quality,
                    resolution: resolution,
                    format: format
                };
                
                imageToVideoConverter.updateSettings(newSettings);
                showStatus('success', `Settings updated: ${frameRate} FPS, ${quality} quality, ${resolution} resolution`);
            } else {
                showStatus('info', `Settings will be applied: ${frameRate} FPS, ${quality} quality, ${resolution} resolution`);
            }
            
            closeSettings();
        }

        // Test functions for validation - Updated for Step 1.2 and 1.4
        window.testInterface = {
            getSelectedFiles: () => selectedFiles,
            getFolderName: () => folderName,
            selectTestFolder: (testFiles) => {
                // Create a mock result object for testing
                const mockResult = {
                    method: 'test',
                    files: testFiles.filter(file => window.fileSystemModule.isJPEGFile(file)),
                    folderName: 'test_folder',
                    success: true
                };
                handleFolderSelectionResult(mockResult);
            },
            isProcessButtonEnabled: () => !document.getElementById('processBtn').disabled,
            getFileSystemModule: () => window.fileSystemModule,
            getBrowserCapabilities: () => window.fileSystemModule.getBrowserInfo(),
            validateJPEGFile: (file) => window.fileSystemModule.isValidJPEGFile(file),
            validateJPEGSignature: (file) => window.fileSystemModule.validateJPEGSignature(file),
            validateFilesBatch: (files, options) => window.fileSystemModule.validateFilesBatch(files, options),
            // Step 1.4: Sorting functionality
            sortFiles: (files, method) => window.fileSystemModule.sortFiles(files, method),
            sortFilesNatural: (files) => window.fileSystemModule.sortFilesNatural(files),
            sortFilesByDate: (files) => window.fileSystemModule.sortFilesByDate(files),
            analyzeSortingPattern: (files) => window.fileSystemModule.analyzeSortingPattern(files),
            changeSortingMethod: (method) => changeSortingMethod(method),
            displaySortingInfo: (analysis) => displaySortingInfo(analysis)
        };
    </script>
    
    <!-- Phase 2: Video Generation Engine -->
    <script src="progressTracker.js"></script>
    <script src="errorHandler.js"></script>
    <script src="customVideoEncoder.js"></script>
    <script src="imageToVideoConverter.js"></script>
    
    <!-- Phase 3: Output and File Handling -->
    <script src="fileSaver.js"></script>
    <script src="successFailureReporter.js"></script>
</body>
</html>
